**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report #3 – Code Coverage, Adequacy Criteria and Test Case Correlation**

| Group 23:         |          |
| ----------------- | -------- |
| Nicole Heather    | 30163278 |
| Nora Melik        |          |
| Nelson Thompson   |          |
| Jennifer Jay      |          |

(Note that some labs require individual reports while others require one report
for each group. Please see each lab document for details.)

# Outline

This design component requires that you and your team measure the adequacy of your test suite using one or more code coverage tools and report about the pros and cons of your metrics and tool choices

Measurement of code coverage is performed in two main steps. First, classes must be selected for instrumentation. Classes selected for instrumentation are the classes which will have the coverage measured. Then, the test suite must be run with a coverage tool. You can use any coverage analysis tool. You need to report three coverage metrics (the suggested metrics to report are: statement, branch, and condition coverages).

NOTE1: If the coverage tool that you are using does not support any of the above metrics, first try another tool. If none reports the above measures, then replace the missing measure with another metric that the tool supports, e.g. you might decide to replace condition coverage with method coverage, if you are using EclEmma

NOTE2: Document all coverage tools you tried and what worked or did not work for your configuration. Explain what you fixed (e.g., removing mock objects, updating IDEs, switching to another tool, etc.)

NOTE3: You need to report the pros and cons of tools you tried and the metrics you chose.

To become more familiar with data flow coverage and achieve a deeper understanding of how coverage tools work, calculate the DU-pair coverage for two methods, by hand. The methods to analyze are: DataUtilities.calculateColumnTotal and one method of your choice from the org.jfree.data.Range class (that you have a test set for, from Assignment 2). Calculate the DU-pair coverage by tracing through the execution of each of your test cases for these methods, manually. This will need to be included in your report. You need to report the followings per method:

the data flow graph

the def-use sets per statement

list all DU-pairs per variable

for each test case show which pairs are covered

calculate the DU-Pair coverage

In this section, you will be required to design new unit tests for two classes to increase their code coverage. The classes to be tested are: org.jfree.data.DataUtilities and org.jfree.data.Range. Note that although the focus in adequacy criteria has changed (it is now on source code), to develop new test cases the test oracle should still be derived from the requirements (as contained in the Javadocs of the SUT)

As with any testing to be done, to begin with, a plan must be created. Document this test plan, as it will be included with your lab report. This plan should include information about who will create which tests, how you plan to develop tests to achieve the adequacy criteria. For thiassignment, a test suite should be developed which has at least thfollowing coverage for each of the classes under test

Minimum coverage:

90% statement coverage

70% branch coverage

60% condition coverage

Students should now have a good understanding of measuring test suite adequacy based on coverage of the SUT’s code. This should include an understanding of some of the different control flow and data flow coverage criteria, and the relative difficulty to satisfy these coverage criteria. Students should now have an idea of some of the trade-offs that occur when choosing different test suite adequacy criteria for testing

# 1 Introduction

Software testing is a process that takes a serious amount of time to plan and schedule, as in order to enusre that your test cases and suites are actually effective developers and engineers must carefully examine their existing code. In contrary to black-box testing, white-box testing allows a developer access to the code and documentation. This means that intead of looking at a program from an outisde perspective, we actually know the logic and paths that a program has, which also means that we are able to expand on the kind of test cases we can create. Now, us testers must consider the coverage of the tests, whether they are able to account for every possible statement, condition, branch and decision that a program will make. 

# 2 Manual data-flow coverage calculations for X and Y methods

### MAKE A DATA_FLOW GRAPH

Range:
    Due to the limted logic and constructor throwing exceptions when lower is larger than upper in the Range class the possiblity of full data-flow coverage is very limited. This results in in branches not being taken, as without setters for upper and lower or a change to the constructor the branches within our 5 fucntions will always be missed. There is also somthing to note as the definitions for all these functions will always be 0, as these values are made and assigned in the constructor wich is not a part of the functions we are testing. In order to make clear the method used for manual calculations, assume we make nodes for each line of code in each function starting at 1.

Data-Flow Graphs:
- ToString():
- GetUpperBound():
- GetLowerBound():
- GetCentralValue():
- GetLength():
## Double check this
| Value | Function          |   defs   |   uses                 |   du-paths   |   du-pairs   |  Covered          |
|-------|-------------------|----------|------------------------|--------------|--------------|-------------------|
| lower | ToString()        |  None    | use(1)                 | None         | None         | True              |
|       | GetUpperBound()   |  None    | use(1), use(2)         | None         | None         | True, False       |
|       | GetLowerBound()   |  None    | use(1), use(2), use(3) | None         | None         | True, Flase, True |
|       | GetCentralValue() |  None    | use(1)                 | None         | None         | True              |
|       | GetLength()       |  None    | use(1), use(2), use(3) | None         | None         | True, False, True |
| upper | ToString()        |  None    | use(1)                 | None         | None         | True              | 
|       | GetUpperBound()   |  None    | use(1), use(2), use(3) | None         | None         | True, False, True |
|       | GetLowerBound()   |  None    | use(1), use(2)         | None         | None         | True, False       |
|       | GetCentralValue() |  None    | use(1)                 | None         | None         | True              |
|       | GetLength()       |  None    | use(1), use(2), use(3) | None         | None         | True, False, True |

For this table, in GetUpperBound, GetLowerBound and GetLength, use(2) is unreachable, and technically not covered.

data-flow coverage with the inclusion of the unreachable code:
- True / Total =  14 / 20 * 100 = 70%

data-flow coverage without the inclusion of the unreachable code:
- True / Total = 14 / 124* 100 = 100% 

# 3 A detailed description of the testing strategy for the new unit test

Range:

Functions being tested:
| Methods                       | Requirements             |
|-------------------------------|--------------------------|
| getCentralValue() : double    | Returns a central value  |
| getLength() : double          | Returns as length        |
| getLowerBound() : double      | Returns the lower bound  | 
| getUpperBound() : double      | Returns the upper bound  |
| toString() : java.lang.String | Returns a string         | 

Test Objectives:
Becasue our coverage is limited by the source code, we mainly focused on the extension of the requirements we are still able to test. This includes expanding the possible input values to ensure that the existsing logic is able to account for any many edge cases as possible while still fuffilling its desired computational or formatting requirements. 

Limitatons and Concerns: 
There is not much to improve on with the data-flow coverage with the range classes without changing the source code to allow for cases where lower is larger than upper. What we can do instead is expand our previous cases to account for more kind of data to ensure that the return values for these functions are still both correct and consistant. Also due to the simplicity of these test cases expansion is slightly easier as the mostly consist of object creation and assertions.

DataUtilities:



White-Box Testing:
Unlike in assignment 2, we have been given full access to the source code of the SUT. This allows us to take a look into the behavioural functionality of the code, in which we must edit or add new test cases to ensure that we have as much coverage as possible. 

Test Criteria:
There is no specified exit or suspension criteria, the main goal of this lab is the planning and execution of JUnit testing.

Distribution:
| Group Member | Assigned Class | Other Group Work             |
|--------------|----------------|------------------------------|
| Nicole       | Range          | Report                       |
| Nelson       | Range          | Review and Quality Assurance |
| Jen          | DataUtilities  | Review and Quality Assurance |
| Nora         | DataUtilities  | Report                       |

Resource Planning:
- System Resources:
  | No.| Resources | Description                      |
  |----|-----------|----------------------------------|
  | 1. | Computer  | Needs to be able to run Eclipse  | 
  | 2. | Eclipse   | Needs correct developer suite    |
  | 3. | JUnit     | Need correct extensions          |
  | 4. | EclEmma   | Need the correct coverage tool   |

- Human Resources:
  | No.| Resources       | Description                                                  |
  |----|-----------------|--------------------------------------------------------------|
  | 1. | Test Manager    | Manage and direct the testing design and execution           |
  | 2. | Test Writers    | Write and debug the creation of JUnit classes                |
  | 3. | Quality Assurer | Ensure the report, documentation and code meets requirements |
  | 4. | Report Writer   | Documents planning, design and answers lab questions         |


# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage

Range:

  Motivation: As mentioned before, our coverage options are limited by the source code.Some functions, however have computations, uses or returns as part of its functionality, and so it must be tested to ensure the proper output everytime it is called regardless of the values of lower and upper. We have expaned on the 
  input values for this function in order to cover more of the calculations consistancy. Becasue class Range has a very large domain that upper and lower ca be, we did our best to keep inputs slightly random, but still relevant to what we were testing.

1. toString(): toString_OppositeRange()
   - Coverage: As for the data-flow and the other coverages, the values of lower and upper where defined elsewhere in the contstuctor, so this means that there is only one use in this fucnction, which has already been covered. There are also no other satements, branches or conditions to cover.
   - Result: Originally, this test class only contained values that were decimals or zeros, so in order to expand the testing of this class we introduced values that were inputted into the constructor as integers, following the original partitions made in assignment 2. This allowed the testing class to expand on the functionality and inner logic of this function. 
  
2. getLength(): getLength_EqualNegative_Decimal()
   - Coverage: There are 2 branch decisions in this function, along with 4 statements and an exception thrown. Although we can only partially cover these, we cans still test the code we can access including the p-use and c-use with both values of upper and lower.  
   - Result: Previously, we had only had the values of lower and upper be integer values only, we decided to expand on this by including float values following the same parititons as in assignment 2. These paritions ensure that our computations and branch statements execute as required. However, if we were able to reach our message and exception, we would create a new test that would have the branch statement be true, and that it throws the correct exception.
  
3. getLowerBound(): getLowerBound_ZeroPositiveRange_Decimal()
   - Coverage: There are 2 branch decisions within this function and 2 possible conditions and 5 statements, as well as a p-use and c-use (construction of the message). The true branch message has not been covered along with the message creation, however the first branch condition was covered along with the return statement.
   - Result: Much like the functions above we expanded on the range of possible inputs. If we did have access to the unreachible code we would have to create a test case that sets the branch condition to true so we can check to see if the message construction is correct along with the proper exception being thrown. 
  
4. getUpperBound(): getUpperBound_LargeRange_Decimal()
   - Coverage: The coverage for this function is exaclty the same as getLowerBound(), the only difference being that now we are returning upper.
   - Result: The result for this function is exactly the same as getLowerBound, the only difference being thaat we are returning upper.
  
5. getCentralValue(): getCentralValue_SmallRange()
   - Coverage: There is not much in way of lack of coverage in our previous test cases consiering there is only one line of code, however since this function has a c-use for both of our values it is cricual that we ensure this function fuffills its requirements correclty. 
   - Result: Much like the preivous newly name test cases, we have expanded on the input variables.

DataUtilities:

1. 

# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)

Range (with the unreachable code, and condition being manually calculated): 
|Coverage Type | ToString() | GetCentralValue() | GetLength() | GetUpperBound() | GetLowerBound |  Avg   |
|--------------|------------|-------------------|-------------|-----------------|---------------|--------|
| Statement    |    100%    |      100%         |    36.4%    |    30.0%        |    30.0%      | 59.28% | 
| Branch       |    NA      |       NA          |    50.0%    |    50.0%        |    50.0%      | 50.0%  |
| Condition    |    NA      |       NA          |    50%      |    50.0%        |    50.0%      | 50.0%  |
| Method       |    100%    |      100%         |    100%     |    100%         |    100%       | 100%   |

(Insert screenshot)

DataUtilities:
|Coverage Type | Coverage % |
|--------------|------------|
| Statement    |            |
| Branch       |            |
| Condition    |            |

(Insert screenshot)

# 6 Pros and Cons of coverage tools used and Metrics you report

The only coverage tools used was EclEmma, the metrics that we used from the tool only gave a calculation on the coverage as a whole. This meant that we had a simple and reliable tool at our disposal. We needed to take some more time to fully examine our codes coverage as the output from EclEmma is not very detailed until you got to the testcases themselves and take a look at the highlights on the the code. EclEmma also runs the entire application as a coverage test, which can result in needing to sift through outputs to find our classes.

The main kinds of metrics we used in order to caclulate our coverage where coverage percents based on the following categoreis; data-def, data-use, statement, branch, decision and method coverage. These were calculated manually with our own review of our code and with the EclEmma coverage tool. These metric provided an understanable way to analyze the coverage of our tests, as our code is not that complicated it is slightly easier to track the progess through methods.The only metric that was not entirely useful was the method coverage metric, as we know that we only have 5 functions to test.

# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.

Requirement Based Testing:
This form of testing is a great tool for the output and functionality of a program. Its focus on the requirements of a system allows for a deep exploration on the correctness and on the unseen logic of a system. It its slightly more simple in its approach since there is only so much a programmer can do without access to code, this results in the manpower required being minimal if you are efficient with your time. Unlike coverage based testing, 


Coverage Based Testing: 
Coverage testing is more focuesed on the inner workings of the code, and how its behaviour effects the functionality of the program. Compared to black-box testing, it is far more exhasutive in how it tests code. This means that it takes much more time to come up with coverage calculations, graphs and new tests to ensure testing meet its standards. However unlike black-box testing, this method is far more adventageous un undertsaning the behaviour of a program, and catching any cases that back-box testing may have missed with its focus on requirements inseatad of inner logic. 

# 8 A discussion on how the team work/effort was divided and managed

The lab begain with the splitting up of classes to review and change. Becasue we are re-using code from the previous assignment, we decided to split members accoding to the tests they had worked on in assignment 2. This made the review and edit of the code far easier as each member was familiar with the suites they worked on. Due to the difference in coverage and logic complexity, the people who worked on the Range class took more responsibility with the lab report, documentation and scheduling in order to lessen the load on members that had to make more drastic change to thier code. 

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab

A difficulty faced in this lab was the planning phase of the assignment. Becasue we are white-box testing we now have to consider a far more complex planning phase along with the review and consideration of the code we have previously made in assignment 2. Despite the issues faced, the biggest lesson we did learn was also how to plan and execute white-box and coverage testing. This lab allowed for a lot of experimentaton and exploration of how these can be done, even if you have code that is mostly covered, you can still find ways to make it better. 

However there was a massive issue with the source code we had to use, with so much code unreachible by the nature of the classes it feels like we where unable to fully deliver on what the assignment was asking for without having to make clear that this is an issue we cannot fix. This is rather frusturating as we know how to correct this, its just not possible in the code without causing errors.

# 10 Comments/feedback on the lab itself

Some of the instructions can be slightly confusing, it might be an improvement to provide a little more detail as to what is required with the manual calculations and planning documentation. White-box testing can be complex and confusing when in practice for the first time, so some more guidance on would provide more chances to learn this process. On the other hand, this lab was a educational look at how we can always improve the coverage and functionality of testing, especially when you have already testing a program using different methods. 

We think proper care should be taken to ensure that the source code we are using allows us to fully deliver on the requirments of this assignment. This may have been a simple oversight, but it was confusing to deal with considering the aim of this assignment. 