**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report #3 – Code Coverage, Adequacy Criteria and Test Case Correlation**

| Group 23:         |          |
| ----------------- | -------- |
| Nicole Heather    | 30163278 |
| Nora Melik        |          |
| Nelson Thompson   |          |
| Jennifer Jay      |          |

(Note that some labs require individual reports while others require one report
for each group. Please see each lab document for details.)

# Outline

This design component requires that you and your team measure the adequacy of your test suite using one or more code coverage tools and report about the pros and cons of your metrics and tool choices

Measurement of code coverage is performed in two main steps. First, classes must be selected for instrumentation. Classes selected for instrumentation are the classes which will have the coverage measured. Then, the test suite must be run with a coverage tool. You can use any coverage analysis tool. You need to report three coverage metrics (the suggested metrics to report are: statement, branch, and condition coverages).

NOTE1: If the coverage tool that you are using does not support any of the above metrics, first try another tool. If none reports the above measures, then replace the missing measure with another metric that the tool supports, e.g. you might decide to replace condition coverage with method coverage, if you are using EclEmma

NOTE2: Document all coverage tools you tried and what worked or did not work for your configuration. Explain what you fixed (e.g., removing mock objects, updating IDEs, switching to another tool, etc.)

NOTE3: You need to report the pros and cons of tools you tried and the metrics you chose.

To become more familiar with data flow coverage and achieve a deeper understanding of how coverage tools work, calculate the DU-pair coverage for two methods, by hand. The methods to analyze are: DataUtilities.calculateColumnTotal and one method of your choice from the org.jfree.data.Range class (that you have a test set for, from Assignment 2). Calculate the DU-pair coverage by tracing through the execution of each of your test cases for these methods, manually. This will need to be included in your report. You need to report the followings per method:

the data flow graph

the def-use sets per statement

list all DU-pairs per variable

for each test case show which pairs are covered

calculate the DU-Pair coverage

In this section, you will be required to design new unit tests for two classes to increase their code coverage. The classes to be tested are: org.jfree.data.DataUtilities and org.jfree.data.Range. Note that although the focus in adequacy criteria has changed (it is now on source code), to develop new test cases the test oracle should still be derived from the requirements (as contained in the Javadocs of the SUT)

As with any testing to be done, to begin with, a plan must be created. Document this test plan, as it will be included with your lab report. This plan should include information about who will create which tests, how you plan to develop tests to achieve the adequacy criteria. For thiassignment, a test suite should be developed which has at least thfollowing coverage for each of the classes under test

Minimum coverage:

90% statement coverage

70% branch coverage

60% condition coverage

Students should now have a good understanding of measuring test suite adequacy based on coverage of the SUT’s code. This should include an understanding of some of the different control flow and data flow coverage criteria, and the relative difficulty to satisfy these coverage criteria. Students should now have an idea of some of the trade-offs that occur when choosing different test suite adequacy criteria for testing

# 1 Introduction

Software testing is a process that takes a serious amount of time to plan and schedule, as in order to enusre that your test cases and suites are actually effective developers and engineers must carefully examine their existing code. In contrary to black-box testing, white-box testing allows a developer access to the code and documentation. This means that intead of looking at a program from an outisde perspective, we actually know the logic and paths that a program has, which also means that we are able to expand on the kind of test cases we can create. Now, us testers must consider the coverage of the tests, whether they are able to account for every possible statement, condition, branch and decision that a program will make. 


# 2 Manual data-flow coverage calculations for X and Y methods

### MAKE A DATA_FLOW GRAPH

Check coverage for current (how the fuck do you make a manual calculation, maybe make a CFG)

Range:
    Due to the limted logic and constructor throwing exceptions when lower is larger than upper in the Range class the possiblity of full data-flow coverage is very limited. This results in in branches not being taken, as without setters for upper and lower or a change to the constructor the branches within our 5 fucntions will always be missed. There is also somthing to note as the definitions for all these functions will always be 0, as these values are made and assigned in the constructor wich is not a part of the functions we are testing. In order to make clear the method used for manual calculations, assume we make nodes for each line of code in each function starting at 1.

Data-Flow Graphs:
- ToString():
- GetUpperBound():
- GetLowerBound():
- GetCentralValue():
- GetLength():

| Value | Function          |   defs   |   uses                 |   du-paths   |   du-pairs   |  Covered          |
|-------|-------------------|----------|------------------------|--------------|--------------|-------------------|
| lower | ToString()        |  None    | use(1)                 | None         | None         | True              |
|       | GetUpperBound()   |  None    | use(1), use(2)         | None         | None         | True, False       |
|       | GetLowerBound()   |  None    | use(1), use(2), use(3) | None         | None         | True, Flase, True |
|       | GetCentralValue() |  None    | use(1)                 | None         | None         | True              |
|       | GetLength()       |  None    | use(1), use(2)         | None         | None         | True, False       |
| upper | ToString()        |  None    | use(1)                 | None         | None         | True              | 
|       | GetUpperBound()   |  None    | use(1), use(2), use(3) | None         | None         | True, False, True |
|       | GetLowerBound()   |  None    | use(1), use(2)         | None         | None         | True, False       |
|       | GetCentralValue() |  None    | use(1)                 | None         | None         | True              |
|       | GetLength()       |  None    | use(1), use(2)         | None         | None         | True, False       |

For this table, in GetUpperBound, GetLowerBound and GetLength, use(2) is unreachable, and technically not covered.

data-flow coverage with the inclusion of the unreachable code:
- True / Total =  12 / 19 * 100 = 63.16%

data-flow coverage without the inclusion of the unreachable code:
- True / Total = 12 / 12 * 100 = 100% 

# 3 A detailed description of the testing strategy for the new unit test

Range:

Functions being tested:
| Methods                       | Requirements             |
|-------------------------------|--------------------------|
| getCentralValue() : double    | Correctness, consistency |
| getLength() : double          | Correctness, consistency |
| getLowerBound() : double      | Correctness, consistency | 
| getUpperBound() : double      | Correctness, consistency |
| toString() : java.lang.String | Correctness, consistency | 

## Test Objectives: Talk with Nelson
Becasue our coverage is limited by the source code, we mainly focused on the 

Limitatons and Concerns: 
There is not much to improve on with the data-flow coverage with the range classes without changing the source code to allow for cases where lower is larger than upper. What we can do instead is expand our previous cases to account for more kind of data to ensure that the return values for these functions are still both correct and consistant. Also due to the simplicity of these test cases expansion is slightly easier as the mostly consist of object creation and assertions.

DataUtilities:



White-Box Testing:
Unlike in assignment 2, we have been given full access to the source code of the SUT. This allows us to take a look into the behavioural functionality of the code, in which we must edit or add new test cases to ensure that we have as much coverage as possible. 

Test Criteria:
There is no specified exit or suspension criteria, the main goal of this lab is the planning and execution of JUnit testing.

Distribution:
| Group Member | Assigned Class | Other Group Work             |
|--------------|----------------|------------------------------|
| Nicole       | Range          | Report                       |
| Nelson       | Range          | Review and Quality Assurance |
| Jen          | DataUtilities  | Review and Quality Assurance |
| Nora         | DataUtilities  | Report                       |

Resource Planning:
- System Resources:
  | No.| Resources | Description                      |
  |----|-----------|----------------------------------|
  | 1. | Computer  | Needs to be able to run Eclipse  | 
  | 2. | Eclipse   | Needs correct developer suite    |
  | 3. | JUnit     | Need correct extensions          |
  | 4. | EclEmma   | Need the correct coverage tool   |

- Human Resources:
  | No.| Resources       | Description                                                  |
  |----|-----------------|--------------------------------------------------------------|
  | 1. | Test Manager    | Manage and direct the testing design and execution           |
  | 2. | Test Writers    | Write and debug the creation of JUnit classes                |
  | 3. | Quality Assurer | Ensure the report, documentation and code meets requirements |
  | 4. | Report Writer   | Documents planning, design and answers lab questions         |


# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage

Range:

1. ToString() (This functions only had doubles or something)
2. getLength()
3. getLowerBound()
4. getUpperBound()
5. getCentralValue()

DataUtilities:

1. 

# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)

Range (ignoring the unreachable code): 
|Coverage Type | Coverage % |
|--------------|------------|
| Statement    |    100     |
| Branch       |    100     |
| Condition    |    100     |  

(Insert screenshot)

DataUtilities:
|Coverage Type | Coverage % |
|--------------|------------|
| Statement    |            |
| Branch       |            |
| Condition    |            |

(Insert screenshot)

# 6 Pros and Cons of coverage tools used and Metrics you report

The only coverage tools used was EclEmma, the metrics that we used from the tool only gave a calculation on the coverage as a whole. This meant that we had a simple and reliable tool at our disposal. We needed to take some more time to fully examine our codes coverage as the output from EclEmma is not very detailed until you got to the testcases themselves and take a look at the highlights on the the code. EclEmma also runs the entire application as a coverage test, which can result in needing to sift through outputs to find our classes.

The main kinds of metrics we used in order to caclulate our coverage where coverage percents based on the following categoreis; data-def, data-use, statement, branch and decision. These were calculated manually with our own review of our code and with the EclEmma coverage tool. 

# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.

Requirement Based Testing:
This form of testing is a great tool for the output and functionality of a program. Its focus on the requirements of a system allows for a deep exploration on the correctness and on the unseen logic of a system. It its slightly more simple in its approach since there is only so much a programmer can do without access to code, this results in the manpower required being minimal if you are efficient with your time. Unlike coverage based testing, 


Coverage Based Testing: 
Coverage testing is more focuesed on the inner workings of the code, and how its behaviour effects the functionality of the program. Compared to black-box testing, it is far more exhasutive in how it tests code. This means that it takes much more time to come up with coverage calculations, graphs and new tests to ensure testing meet its standards. However unlike black-box testing, this method is far more adventageous un undertsaning the behaviour of a program, and catching any cases that back-box testing may have missed with its focus on requirements inseatad of inner logic. 

# 8 A discussion on how the team work/effort was divided and managed

The lab begain with the splitting up of classes to review and change. Becasue we are re-using code from the previous assignment, we decided to split members accoding to the tests they had worked on in assignment 2. This made the review and edit of the code far easier as each member was familiar with the suites they worked on. Due to the difference in coverage and logic complexity, the people who worked on the Range class took more responsibility with the lab report, documentation and scheduling in order to lessen the load on members that had to make more drastic change to thier code. 

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab

A difficulty faced in this lab was the planning phase of the assignment. Becasue we are white-box testing we now have to consider a far more complex planning phase along with the review and consideration of the code we have previously made in assignment 2. Despite the issues faced, the biggest lesson we did learn was also how to plan and execute white-box and coverage testing. This lab allowed for a lot of experimentaton and exploration of how these can be done, even if you have code that is mostly covered, you can still find ways to make it better. 

# 10 Comments/feedback on the lab itself

Some of the instructions can be slightly confusing, it might be an improvement to provide a little more detail as to what is required with the manual calculations and planning documentation. White-box testing can be complex and confusing when in practice for the first time, so some more guidance on would provide more chances to learn this process. On the other hand, this lab was a educational look at how we can always imporve the coverage and functionality of testing, especially when you have already testing a program using different methods. 